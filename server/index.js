const https = require("https");
const fs = require("fs");
const WSOPEN = require("ws").OPEN;
const WebSocketServer = require("ws").Server;
var url = require("url");

const dgram = require("dgram");
const udp4 = dgram.createSocket("udp4");

/**
 * API config
 */
const API = {
	/**
	 * A https server listen to requests here and handle most of
	 * the management and meta data for clients
	 */
	PORT: 55555,
	/**
	 * The low latency opus stream will use this port
	 */
	UDP_PORT: 55556,
	/**
	 * Websocket audio needs the connection to be https
	 * so we also need certs
	 */
	CREDENTIALS: {
		key: fs.readFileSync("./cert/privkey.pem"),
		cert: fs.readFileSync("./cert/cert.pem")
	}
};

var tempId = 0;
const UTIL = {
	/**
	* Will simply return a unique id
	*/
	generateId: function () {
		return "" + (tempId++);
	},
	ipFromReq: function(req) {
		return req.headers['x-forwarded-for'] || req.connection.remoteAddress || 
		req.socket.remoteAddress || (req.connection.socket ? req.connection.socket.remoteAddress : null);
	},
	log: function(s, req = false) {
		var ip = "";
		var d = new Date();
		var date = ("0" + d.getDate()).slice(-2) + "-" + ("0"+(d.getMonth()+1)).slice(-2) + "-" +
			d.getFullYear() + " " + ("0" + d.getHours()).slice(-2) + ":" + ("0" + d.getMinutes()).slice(-2);
		if (req) {
			ip = this.ipFromReq(req);
		}
		if (ip) {
			console.log(date + " | " + ip + " | " + s);
		}
		else {
			console.log(date + " | " + s);
		}
	},
	removeFromArray: function(arr, el) {
		const index = arr.indexOf(el);
		if (index >= 0) {
			arr.splice(index, 1);
		}
		return arr;
	}
}

class Connection {
	constructor(from, to) {
		this.from = from;
		this.to = to;
	}
}

class Client {
	constructor(ip, port, id = false) {
		/**
		 * A unique id generated by the server
		 */
		if (id) {
			this.id = id;
		}
		else {
			this.id = UTIL.generateId();
		}
		this.ip = ip;
		this.port = port;
		/**
		 * If it's a wesocket connection
		 */
		this.webSocket = null;
	}

	setAddress(ip, port) {
		this.ip = ip;
		this.port = port;
	}
}

let clients = [];
let connections = [];

function handleOpusPacket(packet, info) {
	console.log(packet);
	console.log(info);
	debugger;
}


/**
 * Will register a client and generate an id for it if none is provided
 * @param {Number} port The port of the clinet
 * @param {string} ip IP of the client
 * @param {string} id The id of the clinet, can be empty if the client is new
 * @returns {string} Will return the client has
 */
function registerClient(port, ip, id) {
	if (id) {
		for (let i of clients) {
			if (i.id === id) {
				i.setAddress(ip, port);
				UTIL.log("Register: Updated existing client " + ip + " id " + id);
				return id;
			}
		}
	}
	const c = new Client(ip, port, id);
	clients.push(c);
	UTIL.log("Register: new client " + ip + " id " + c.id);
	return c.id;
}

/**
 * Will add a listener to the client from selfIf
 * @param {string} selfId Id from the broadcasting client
 * @param {string} peerId Id from the listener client
 */
function addListener(selfId, peerId) {
	let self;
	let peer;
	// find the actual objects
	for (let i of clients) {
		if (i.id === selfId) {
			self = i;
		}
		if (i.id === peerId) {
			peer = i;
		}
	}

	if (self && peer) {
		/**
		 * A listener can only listen to one stream
		 * So we'll get rid of any old connections which have
		 * the target as a listener
		 */
		for (let i of connections) {
			if (i.to === i) {
				connections = UTIL.removeFromArray(connections, i);
			}
		}

		connections.push(new Connection(self, peer));
		return true;
	}
	return false;
}

/**
 * Will connect clients in both ways
 * @param {string} selfId Id from client a
 * @param {string} peerId Id from client b
 */
function connectClients(selfId, peerId) {
	let success = true;
	success = success && addListener(selfId, peerId);
	success = success && addListener(peerId, selfId);
	return success;
}

/**
 * Will remove all connections to and from a client and the client it self
 * @param {string} selfId The id of the client
 */
function disconnectClient(selfId) {
	for (let i of clients) {
		if (i.id === selfId) {
			for (let j of connections) {
				if (j.to === i || j.from === i) {
					connections = UTIL.removeFromArray(connections, j);
				}
			}
			clients = UTIL.removeFromArray(clients, i);
			return;
		}
	}
}


/**
 * The main API server handler
 */
const handleAPIRequest = function(req, res) {
	const parsed = url.parse(req.url, true);
	const pathname = parsed.pathname;
	var response = { type: "not_set" };

	/**
	 * All clients will have to register first, even if they already have an id from some earlier session
	 */
	if ("/register" === pathname) {
		response.type = "register_result";
		response.id = registerClient(parsed.query["port"], UTIL.ipFromReq(req), parsed.query["id"]);
	}

	/**
	 * Will connect the clients in both directions
	 */
	if ("/connect" === pathname) {
		response.type = "connection_result";
		response.success = connectClients(parsed.query["id"], parsed.query["peer"]);
	}

	/**
	 * Will connect only one way which is going to be used for the web listener
	 */
	if ("/connect_listener" === pathname) {
		response.type = "connection_result";
		response.success = addListener(parsed.query["id"], parsed.query["peer"]);
	}

	/**
	 * Will remove a client
	 */
	if ("/disconnect" === pathname) {
		disconnectClient(parsed.query["id"]);
	}

	res.writeHead(200, {"Content-Type": "text/html"});
	res.end(JSON.stringify(response));
};

let apiServer = https.createServer(API.CREDENTIALS, handleAPIRequest).listen(API.PORT);
UTIL.log("API server started on " + API.PORT);

/**
 * The websocket server for opus packets
 */
let wssServer = new WebSocketServer({ server: apiServer });
wssServer.on("listening", () => {
	UTIL.log("WSS server started on " + API.PORT);
});

wssServer.on("connection", (ws, request, client) => {
	// TODO need to find the correct client first
	debugger;
	ws.on("message", (message) => {
		// TODO send the packet to all the, not a priority
		handleOpusPacket(message, client);
		debugger;
	});
	ws.on("close", () => {
		// TODO get rid of the client from this connection
		debugger;
    });
});

/**
 * The udp server for opus packets
 */
udp4.on("message", (message, rinfo) => {
	handleOpusPacket(message, rinfo);
});

udp4.on("listening", () => {
	UTIL.log("UDP server started on " + API.UDP_PORT);
});

udp4.bind(API.UDP_PORT);


// TODO start a time which clears out sockets which haven't recieved any packets in a while 